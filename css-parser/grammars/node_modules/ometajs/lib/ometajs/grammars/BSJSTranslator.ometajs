ometa BSJSTranslator {
  trans      = [:t apply(t):ans]     -> ans,
  curlyTrans = [#begin curlyTrans:r] -> r
             | [#begin trans*:rs]    -> ('{' + rs.join(';') + '}')
             | trans:r               -> ('{' + r + '}'),

  this                                                  -> 'this',
  break                                                 -> 'break',
  continue                                              -> 'continue',
  number   :n                                           -> n,
  string   :s                                           -> JSON.stringify(s),
  regExp   :x                                           -> x,
  arr      %(this.op = '[]') trans*:xs                  -> ('[' + xs.join(',') + ']'),
  unop     :op {this.op}:prevOp %(this.op = 'u' + op) trans:t -> {
    var res;
    if (op === 'typeof' || op === 'void' || op === 'delete') {
      res = op + ' ' + t;
    } else {
      res = op + t;
    }

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = '(' + res + ')';
    }

    return res;
  },
  getp    %(this.op = '.') :fd trans(fd):tfd trans:x                    -> {
    if (fd[0] === 'string' && /^[$_a-z0-9][a-z0-9]*$/i.test(fd[1]) &&
        !BSJSParser._isKeyword(fd[1])) {
      return x + '.' + fd[1];
    } else {
      return x + '[' + tfd + ']';
    }
  },
  get      :x                                           -> x,
  set {this.op}:prevOp trans:lhs %(this.op = '=') trans:rhs   -> {
    if (BSJSTranslator.comparePriorities(prevOp, '=')) {
      return '('  + lhs + ' = ' + rhs + ')';
    } else {
      return lhs + ' = ' + rhs;
    }
  },
  mset {this.op}:prevOp trans:lhs :op %(this.op = op + '=')
       trans:rhs -> {
    if (BSJSTranslator.comparePriorities(prevOp, op + '=')) {
      return '(' + lhs + ' ' + op + '= ' + rhs + ')'
    } else {
      return lhs + ' ' + op + '= ' + rhs
    }
  },
  binop    :op {this.op}:prevOp %(this.op = op) trans:x trans:y -> {
    var res = x + ' ' + op + ' ' + y;

    if (BSJSTranslator.comparePriorities(prevOp, op)) {
      res = '(' + res + ')';
    }
    return res;
  },
  preop    :op {this.op}:prevOp %(this.op = 'u' + op) trans:x            -> {
    var res = op + x;

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = '(' + res + ')';
    }

    return res;
  },
  postop   :op {this.op}:prevOp %(this.op = 'u' + op) trans:x            -> {
    var res = x + op;

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = '(' + res + ')';
    }

    return res;
  },
  return   trans:x                                      -> ('return ' + x),
  with     trans:x curlyTrans:s                         -> ('with(' + x + ')' + s),
  label    :name curlyTrans:s                           -> (';' + name + ':' + s),
  if       trans:cond curlyTrans:t curlyTrans:e         -> ('if(' + cond + ')' + t + 'else' + e),
  condExpr {this.op}:prevOp %(this.op = '?:') trans:cond trans:t trans:e -> {
    var res = cond + '?' + t + ':' + e;

    if (BSJSTranslator.comparePriorities(prevOp, '?:')) {
      res = '(' + res + ')';
    }
    return res;
  },
  while    trans:cond curlyTrans:body                   -> ('while(' + cond + ')' + body),
  doWhile  curlyTrans:body trans:cond                   -> ('do' + body + 'while(' + cond + ')'),
  for      trans:init trans:cond trans:upd
           curlyTrans:body                              -> ('for(' + init + ';' + cond + ';' + upd + ')' + body),
  forIn    trans:x trans:arr curlyTrans:body            -> ('for(' + x + ' in ' + arr + ')' + body),
  begin    trans:x end                                  -> x,
  begin    (trans:x
              ( end -> x
              | empty                              -> (x  + ';')
              )
           )*:xs                                        -> ('{' + xs.join('') + '}'),
  func     :name :args curlyTrans:body                  -> ('function ' + (name || '') + '(' + args.join(',') + ')' + body),
  call     :fn trans(fn):tfn trans*:args                -> {
    if (fn[1] === null) tfn = '(' + tfn + ')';
    return tfn + '(' + args.join(',') + ')';
  },
  send     :msg trans:recv trans*:args                  -> (recv + '.' + msg + '(' + args.join(',') + ')'),
  new      ( anything:str ?(typeof str === 'string') -> str
           | trans
           ):cls trans*:args                            -> ('new ' + cls + '(' + args.join(',') + ')'),
  var      varItem+:vs                                  -> ('var ' + vs.join(',')),
  varItem = [:n :v trans(v):tv]                         -> {
             n + ' = ' + ((v[0] === 'binop' && v[1] === ',') ? '(' + tv + ')' : tv)
            } | [:n]                                        -> n,
  throw    trans:x                                      -> ('throw ' + x),
  try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f),
  json     trans*:props                                 -> ('{' + props.join(',') + '}'),
  binding  :name trans:val                              -> (JSON.stringify(name) + ': ' + val),
  switch   trans:x trans*:cases                         -> ('switch(' + x + '){' + cases.join(';') + '}'),
  case     trans:x trans:y                              -> ('case ' + x + ': '+ y),
  default          trans:y                              -> ('default: ' + y),
  stmt     :s trans(s):t                                -> {
    if (s[0] === 'function' && s[1] === null || s[0] === 'json') {
      return '(' + t + ')';
    }
    return t;
  }
}

BSJSTranslator.opPriorities = {
  '.': 0, '[]': 0,
  'u++': 1, 'u--': 1,
  'u+': 2, 'u-': 2, 'u!': 2, 'u~': 2, 'utypeof': 2, 'uvoid': 2, 'udelete': 2,
  '*': 3, '/': 3, '%': 3,
  '+': 4, '-': 4,
  '<<': 5, '<<<': 5, '>>': 5,
  '<': 6, '<=': 6, '>': 6, '>=': 6,
  '==': 7, '===': 7, '!=': 7, '!==': 7,
  '&': 8,
  '^': 9,
  '|': 10,
  '&&': 11,
  '||': 12,
  '?:': 13,
  '=': 14, '+=': 14, '-=': 14, '*=': 14, '/=': 14, '%=': 14, '<<=': 14,
  '>>=': 14, '>>>=': 14, '&=': 14, '^=': 14, '|=': 14,
  ',': 15
};

BSJSTranslator.comparePriorities = function (op1, op2) {
  return op1 != undefined &&
      BSJSTranslator.opPriorities[op1] === undefined ||
      BSJSTranslator.opPriorities[op1] < BSJSTranslator.opPriorities[op2];
};
